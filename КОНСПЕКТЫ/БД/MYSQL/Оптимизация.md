## cost 
это оценка оптимизатора, а не реальное время, не нужно пытаться снизить cost любой ценной, полезно будет сравнивать до и после оптимизации
## query_block
Порядок выполнения
Почти всегда Mysql использует Nested Loop Join
- Важно
	- какая таблица первая
	- сколько строк она возращает
	- сколько раз вывполнился вложенный запрос
Первая таблица в Nested Loop должна быть максимально селектиной

## Анализ таблиц
### access_type(критично)

| access_type | Оценка      |
| ----------- | ----------- |
| const       | идеально    |
| eq_ref      | отлично     |
| ref         | нормально   |
| range       | нито нисе   |
| index       | плохо       |
| all         | очень плохо |
### rows
количество вернувших строк
### loops
сколько раз выполнился цикл
### filtered
- % строк которые подойдут условию
- Если
	- rows большое
	- filtered близок к 100%
	- индекс тут не поможет
	
file_sort и temporary_table
Это означает что 
- Mysql создает временную таблицу
- сортирует ее 
- индекс для order by не используется
- Причины
	- Порядок JOIN
	- индекс не покрывает where + order by
### Индексы
possible_keys - какие индексы потенциально могут подойти
key - то что реально было выбранно
Если
- индекс есть в possible_keys
- но не выбран
	- плохая селективность
	- неправильный порядок колонок
	- типы не совпадают
	- условие не SARGable(**Search ARGument ABLE**  
			Условие, которое **может использовать индекс**)
used_key_parts - порядок колонок
```json
"used_key_parts": ["id"]
```
в данном случае под индекс поппадет только часть с id, .., ..

MySQL **не умеет**:
- использовать индекс
- **и одновременно** считать `ROW_NUMBER()`
Window functions → почти всегда
- `filesort`
- `temporary table`
--- 
Про ROW_NUMBER() OVER (PARTITION BY X ORDER BY Y)
требует:
1. получить **ВСЕ строки partition**
2. отсортировать их
3. только потом пронумеровать

Индекс **не может**:
- гарантировать границы partition
- гарантировать порядок _после_ JOIN’ов