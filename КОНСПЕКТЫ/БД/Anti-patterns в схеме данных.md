# EAV (Entity - Atribute - Value)
Как выглядит 
```
entity_id | attribute | value
```
Почему делают:
- гибкая схема
- можно быстро добавлять поля
Почему это плохо:
- невозможны нормальные индексы
- сложные и медленные запросы
- Отсутствие типов данных
- Сложно валидировать
Симптомы:
- Десятки join'ов к одной таблице
- фильтрация по `attribute = 'x'`
Альтернативы:
- Нормализованные таблицы
- JSON с ограниченым scope
- Отдельные таблицы под часто используеммые атрибуты
# Хранение списков в одном поле (CSV/JSON без причины)
Пример
```
user.roles = "admin,manager,operator"
```

Проблемы:
- LIKE `%admin%`
- нет нормальных индексов
- ошибки при обновлении
Альтернатива
- join таблица (user_roles)
- JSON + generated columns
# Отсутствие явных связей (NO FK)
Почему делают
- "FK замедляют"
- "Проверим в коде"
Почему это anti pattern
- мусорные данные
- orphan records
- сложные join и проверки

# Неверные типы данных
### Последствия
- больше памяти
- плохая селективность индексов
- сложные сравнения

# Over-indexing
Как выглядит 
- 8-10 индексов на таблицу
- дублирующиеся индексы
Почему плохо
- медленные INSERT/UPDATE
- рост размера БД
- optimizer путается
## Отсутствие явного primary key

Почему критично
- InnoDB всегда имеет clustered index
- скрытый PK = непредсказуемость
Правильно
- `BIGINT AUTO_INCREMENT`
- или UUID (осознанно)

## Использование UUID как PK без понимания

Проблема
- random insert
- page splits
- фрагментация
Если UUID нужен
- UUIDv7
- separate surrogate key


# Отсутствие soft-delete стратегии

Плохо
- `deleted_at` без индексов
- фильтрация везде
Лучше
- индекс `(deleted_at, ...)`
- архивные таблицы




