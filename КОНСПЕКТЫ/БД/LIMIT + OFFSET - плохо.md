Классический подход к пагинации на уровне бд который использует конструкцию
`LIMIT n OFFSET m` плох по нескольким причинам
1) Проблема с performance
В большинстве реляционных бд `OFFSET` не означает перепрыгнуть к строке `m` и взять `n` элементов, бд должна прочитать и отсканировать все предыдущие строки, отсортировать их и только потом отбросить чтобы по итогу отдать только `n` элементов
- Чем глубже пагинация тем больше нагрузка на CPU и диск
- Проблема "дрейфа"данных: Если во время листания страниц между вашими данными добваиться новая запись, данные на следующей странице могут сдвинуться, и пользователь увидит одну и туже запись дважды
Решение проблемы **Keyset pagination*** 
# Keyset Pagination
Keyset Pagination решавет проблему сканирования лишних строк. Вместо того чтобы говорить «пропусти 1000 строк», мы говорим «дай мне 10 строк, которые идут **после** последней записи, которую я видел».

## Влияние `LIMIT offset, size` на MySQL

В MySQL работа `LIMIT` тесно связана с тем, как движок хранилища (InnoDB) обрабатывает индексы.

1. **Late Row Lookups (Отложенная выборка):** Когда вы делаете `SELECT * ... LIMIT 1000000, 10`, MySQL приходится доставать из диска полные данные для всех миллиона строк, даже если они будут отброшены.
2. **Оптимизация через покрывающие индексы:** Если вы запрашиваете только те поля, которые входят в индекс, MySQL не лезет в основную таблицу (Clustered Index), что работает быстрее. 

_Плохо:_ `SELECT * FROM table LIMIT 100000, 10` 
_Чуть лучше:_ 
```sql 
SELECT * FROM table JOIN 
	(SELECT id FROM table ORDER BY id LIMIT 100000, 10) as tmp USING(id);
```