Мультиплексирование соединений - это механизм который позволяет нескольким клиентским запросам использовать одно физическое соединение с бд вместо создания отдельного соединения под каждого клиента
## Зачем это нужно
Каждое соединение с СУБД:
- потребляет память (контекс, сессии, буферы, кэш)
- испольхуют сетевые ресуры(TCP-сессии, сокеты)
- требует времени на установку (аутентификация, инициализация контекста).
Когда приложений или пользователей много, тысячи отдельных соединений могут перегрузить сервера бд
Мультиплексирование решает эту проблему за счет
1) Экономия ресурсов - меньше активных TCP соединений
2) Быстрого обслуживания - запросы перекидываются через одного или несколько общих соедиений
3) Улучшения масштабируемости - можно обслуживать больше клиентов без увелечения нагрузки на бд
4) Централизованного управления подключениями - контроль таймаутов, пула, приоритизация
# Где и как используется в разных субд
## PostgreSQL
PostgreSQL по умолчанию имеет модель "1 процесс на соединение", без внутреннего мультиплексирования
Для оптимизации используют внешние пулы:
- PgBouncer - Умеет
	- режим session pooling(1 клиент - 1 серверное соединение на время сессии)
	- transaction pooling (каждая транзакция может идти через любое соединение)
	- statement pooling (каждый запрос - отдельное соедиение)
- Это и есть мультиплексирование на уровне пула соединений
## MySQL / MariaDB
Сервер сам не мультиплексирует соединения.
Используют ProxySQL, MySQL Router, MaxScale - они могут:
- держать несколько клиентский соединений
- распределять запросы по меньшему числу физических соединений
## MongoDB
Клиентские драйверы поддерживают connection pooling и multiplexing 
- особенно в новых версиях с **MongoDB 5.0+**, где поддерживается **client-side multiplexing** (несколько операций через одно TCP-соединение с помощью опкодов).
- Это повышает производительность при большом числе коротких операций.
## Redis
Redis работает через один поток, который:
 - использует epoll/select/kqueue для обработки множества клинтов
 - может держать тысячи одновременных TCP соединенний
 - сам мультиплексирует их - читает и пишет данные не блокирующе
Это значит что Redis внутренне мультиплексирует соединения, но на уровне событий, а не логических сессий
### Что это дает 
- не нужно создавать отдельный процесс на клиента
- Минимальная задержка при большом количстве подключений
- Высокая пропускная способнность
### Client-side pooling / multiplexing

- Клиентские библиотеки (например, `redis-py`, `Jedis`, `ioredis`) часто реализуют **пул соединений**:
    
    - Несколько потоков приложения берут соединения из пула.
        
    - Иногда поддерживается **async-multiplexing**, где несколько операций могут выполняться параллельно через одно соединение (особенно в асинхронных клиентах — `aioredis`, `node-redis`).
        
- Redis 6+ добавил **I/O threads**, но они не меняют саму модель соединений — просто ускоряют обработку сетевых операций.
## MemCached
### Как устроенно соединение
- Memcahced изначально спроектирован для многопоточной работы
- Каждый поток обрабатывает набор соединений, используя неблокирующие I/O
- Как и Redis сервер сам мультиплексирует соединения - без отдельного процесса на клиенте
### Что это дает?
- поддержка десятков тысяч клиентов.
- возможность эффективно масштабировать под нагрузку
- минимальный overhead на создание и закрытие соединений
### Клиентское мультиплексирование

- Клиенты (например, `libmemcached`, `pylibmc`) часто держат **persistent connections** и **connection pooling**.
    
- В асинхронных клиентах также можно мультиплексировать запросы (например, в `aiomcache`).