  Очередь это структура данных где элменты обрабатываются в порядке добавлений (FIFO)
# Redis list
- Тип LIST
- Основные команды
	- LPUSH key value - Добавление в начало
	- RPUSH key value - Добавление в конец
	- LPOP key - Удалени еиз начала
	- RPOP key - Удаление с конца
	- LLEN key - Длина списка
	- LRANGE key start stop - Получить элементы
# Блокирующие очереди
Если нужно чтобы потребитель ждал новые задачи 
- BLPOP key [key ...] timeout - блокирует поток до появления элемента или таймаута
- `BRPOP key [key ...] timeout` — аналогично, но с конца списка.
```
BLPOP myqueue 0  # ждёт бесконечно, пока появится элемент
```
Это удобно для реализации воркеров (worker), которые постоянно обрабатывают задачи.

# Pub/Sub как очередь
Redis поддерживает pub/sub, где клиенты подписываются на канал а издатель отправляет сообщения
```
PUBLISH mychannel "task1"
```
- Плюсы: очень быстро, почти real-time.
- Минусы: сообщения теряются, если подписчик оффлайн. Для очереди задач это обычно не подходит.
## **4. Более продвинутые подходы: надежная очередь**

Проблема простых списков: если воркер берёт элемент с помощью `LPOP` и падает, задача теряется.
### **Решение через RPOPLPUSH**

- Команда: `RPOPLPUSH source destination`
- Берём элемент из одной очереди и сразу помещаем в «обработку» (backup queue):
`RPOPLPUSH myqueue processing`

Если воркер успешно обработал задачу — удаляем её из `processing`:

`LREM processing 1 task1`

Если воркер упал — задача остаётся в `processing` и может быть переработана позже.

---

## **5. Использование Sorted Sets для приоритетов**

Для приоритетных задач используют **Sorted Sets** (`ZSET`):

```
ZADD queue 10 task1
ZADD queue 5 task2
ZADD queue 20 task3

ZRANGE queue 0 0  # достать элемент с наименьшим приоритетом
ZREM queue task2   # удалить после обработки
```
Таким образом можно реализовать очереди с приоритетами и временем выполнения.

---

## **6. Примеры реальных паттернов**

1. **Delayed Queue (отложенная очередь)**
    
    - Используем `ZSET`, где score — timestamp, когда задача должна быть выполнена.
    - Периодически проверяем `ZRANGEBYSCORE queue 0 now` и переносим задачи в рабочую очередь.
2. **Reliable Queue (надёжная очередь)**
    - Используем `RPOPLPUSH` или Lua-скрипты для атомарного перемещения задач в очередь обработки и обратно.
3. **Queue with Acknowledgements**
    - Подобно RabbitMQ: воркер подтверждает обработку, только тогда элемент удаляется.
