Горутины представляют собой управляемые(могут быть остановленны в любой момент рантаймом go) параллельные операции, которые могут выполняться независимо от функции в которой они вызваны
Горутины имеют свой стек

Все горутины запускаются в одном адресном пространстве. 
- одна виртуальная память процессора
-  один heap
- общие глобальные переменные 
- общие объекты в памяти
Как только компилятор достигает конца основной горутины(main), он завершит все созданные горутины

В отличие от асинхронных функций в nodejs не разрывают стек

жизненный цикл горутины
```
new -> runnable -> running -> (waiting | runnable) -> dead
```
1) go f() создает `G`
2) `G` попадает в runqueue(P.runq или runnext)
3) M + P берут G -> running
4) Возмолжные переходы
	1) waiting(mutex | chanell)
	2) preemption -> runnable
5) dead
# Утечки горутин
Утечка горутины возникает, когда результат горутины уже никому не нужен, но горутина продолжает работать и потреблять ресурсы=
## Профилактика
1) Завершать горутину, когда от нее все получили
2) Завершать горутину, если произошла ошибка
3) Завершать горутину по отмене контекста
для того чтобы обнаружить утчечки, если их сразу не видно, используют goleak