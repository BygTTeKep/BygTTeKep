G-M-P - это внутреняя модель планировщика Go
Она описывает как горутины реальны выполняются

# G - goroutine
G - это не поток, а структура данных рантайма
- указатель на стек
- регистры
- состояние (`running`, `runnable`, `waiting`)
- ссылка на функцию
Свойста
 - стартовый стек примерно 2KB(растет/сжимается)
 - создание дешевое
 - из может быть сотни тысяч
# M - machine(OS thread)
M - это поток операционной системы
- именно M выполняет машинные инструкции
- может быть заблокирован syscall'ом
- создается и уничтожается рантаймом Go
Код всегда выполняется на M никогда напрямую на G

# P - processor(контекст исполнения)
Владелец локальной очереди горутины
M может выполнить код go только имея P

# Последовательность
1) P содержит очередь runnable goroutine
2) M берет P
3) M исполняет G из очереди P
4) если G блокируется
	1) M отдает P
	2) другой M продолжает работу с этим P
# Очереди исполнения
Есть 2-ух уровневая система
- локальная очередь у каждого P
- глобальная очередь (fallback)
Используется work stealing, тоесть если у P пусто, он может "своровать" часть задач у другого P
# Блокировки и syscall
Обыяный Go блок(chanel, mutex)
- G паркуется
- M продолжает выполнять другие G через тотже P
Блокирующий syscall
- M уходит в syscall
- P отцепляется
- рантайм использует/создает другой M
т.е. один зависший syscall != стоп всего процесса

--- 
Попростому
G - что выполнить
M - где выполнить
P - кому можно выполнять