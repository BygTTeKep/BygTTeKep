Это примитив синхронизации, ограничивающий количество одновременно выполняющихся конкурентных операций.
У семафора есть 2 основных метода: 
1) acquire
2) release
Реализация похожа на mutex, за исключением того что семантически мютексы защищают критическую секцию, 
Пример
```go
package semaphore
var (
  ErrNoTickets      = errors.New("не могу захватить семафор")
  ErrIllegalRelease = errors.New("не могу освободить семафор, не захватив его сначала")
)
// Interface содержит поведение семафора, 
// который может быть захвачен (Acquire) 
// и/или освобожден (Release).
type Interface interface {
  Acquire() error
  Release() error
}

type implementation struct {
  sem     chan struct{}
  timeout time.Duration
}

func (s implementation) Acquire() error {
  select {
  case s.sem <- struct{}{}:
    return nil
  case <-time.After(s.timeout):
    return ErrNoTickets
  }
}

func (s implementation) Release() error {
  select {
  case _ = <-s.sem:
    return nil
  case <-time.After(s.timeout):
    return ErrIllegalRelease
  }
}

func New(tickets int, timeout time.Duration) Interface {
  return &implementation{
    sem:     make(chan struct{}, tickets),
    timeout: timeout,
  }
}
```
